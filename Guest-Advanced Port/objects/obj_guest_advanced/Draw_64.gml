/// @description Execute Full Shader Pipeline

// --- 1. Resolution Enforcement (1:1 Pixel Mapping) ---
var _win_w = window_get_width();
var _win_h = window_get_height();

// Force the App Surface and GUI layer to match the Window exactly.
// This prevents GameMaker's backend from stretching our final result,
// ensuring the shader's own viewport scaling (Pass 12 & 17) handles the aspect ratio.
if (surface_get_width(application_surface) != _win_w || surface_get_height(application_surface) != _win_h) {
    surface_resize(application_surface, _win_w, _win_h);
    display_set_gui_size(_win_w, _win_h);
}

output_width = _win_w;
output_height = _win_h;


// --- 2. Surface Management & Recovery ---
// Defines the resolution logic for every surface in the chain.

var _check_surf = function(_surf, _w, _h, _format) {
    if (!surface_exists(_surf)) {
        return surface_create(_w, _h, _format);
    }
    return _surf;
}

// Input Surface (Game World)
// If lost, recreate and re-attach to View 0 immediately.
if (!surface_exists(surf_game)) {
    surf_game = surface_create(game_width, game_height);
    view_set_surface_id(0, surf_game);
} else {
    // Ensure view is always piping to this surface
    if (view_get_surface_id(0) != surf_game) {
        view_set_surface_id(0, surf_game);
    }
}

// History Buffer (Standard 8-bit is sufficient for raw frames)
for (var i = 0; i < history_size; i++) {
    surf_history[i] = _check_surf(surf_history[i], game_width, game_height, surface_rgba8unorm);
}

// Feedback Buffers (Float precision essential for decay accuracy)
for (var i = 0; i < 2; i++) {
    surf_afterglow[i] = _check_surf(surf_afterglow[i], game_width, game_height, surf_format);
    surf_avglum[i]    = _check_surf(surf_avglum[i], 1, 1, surf_format); // 1x1 Pixel
}

// --- Pipeline Intermediates Resolution Definitions ---

// 1. Pre-NTSC Group (Native Game Resolution)
surf_stock_pass = _check_surf(surf_stock_pass, game_width, game_height, surface_rgba8unorm);
surf_prepass0   = _check_surf(surf_prepass0, game_width, game_height, surf_format);
surf_interlace  = _check_surf(surf_interlace, game_width, game_height, surf_format);

// 2. NTSC Encoding (4x Width)
// scales up to encode signal information
surf_ntsc_1 = _check_surf(surf_ntsc_1, game_width * 4.0, game_height, surf_format); 

// 3. NTSC Decoding Group (2x Width) [CRITICAL FIX]
// Pass 2 scales by 0.5 relative to source. 4.0 * 0.5 = 2.0x Game Width.
// We must maintain this double-width resolution through the sharpening and linearization
// steps to preserve the fringing details generated by the NTSC emulation.
var _decoded_width = game_width * 2.0;

surf_ntsc_2       = _check_surf(surf_ntsc_2, _decoded_width, game_height, surf_format);
surf_ntsc_3       = _check_surf(surf_ntsc_3, _decoded_width, game_height, surf_format);
surf_ntsc_sharpen = _check_surf(surf_ntsc_sharpen, _decoded_width, game_height, surf_format);
surf_prepass      = _check_surf(surf_prepass, _decoded_width, game_height, surf_format);
surf_linearize    = _check_surf(surf_linearize, _decoded_width, game_height, surf_format);

// 4. CRT & Glow Group (Viewport & Absolute Sizes)
surf_pass1   = _check_surf(surf_pass1, output_width, output_height, surf_format);
surf_gauss_h = _check_surf(surf_gauss_h, bloom_width, game_height, surf_format);
surf_glow    = _check_surf(surf_glow, bloom_width, bloom_height, surf_format);
surf_bloom_h = _check_surf(surf_bloom_h, bloom_width, game_height, surf_format);
surf_bloom   = _check_surf(surf_bloom, bloom_width, bloom_height, surf_format);
surf_pass2   = _check_surf(surf_pass2, output_width, output_height, surf_format);


// --- 3. Input Capture ---
// Determine Ring Buffer Indices
var _curr_hist_idx = history_idx;
var _prev_hist_idx = (history_idx - 1 + history_size) % history_size;

// Pass 0: Input -> History (NEAREST)
gpu_set_tex_filter(false); 
surface_set_target(surf_history[_curr_hist_idx]);
    draw_surface(surf_game, 0, 0);
surface_reset_target();

// Pass 1: History -> StockPass (NEAREST)
surface_set_target(surf_stock_pass);
    draw_surface(surf_history[_curr_hist_idx], 0, 0);
surface_reset_target();


// --- 4. Shader Pipeline Execution ---

// Pass 2: Afterglow (LINEAR)
gpu_set_tex_filter(true);
surface_set_target(surf_afterglow[pingpong_write]);
    shader_set(shd_afterglow);
    push_shader_params(shd_afterglow, surf_stock_pass);
    texture_set_stage(s_afterglow_history, surface_get_texture(surf_history[_prev_hist_idx]));
    texture_set_stage(s_afterglow_feedback, surface_get_texture(surf_afterglow[pingpong_read]));
    
    draw_surface(surf_stock_pass, 0, 0);
    shader_reset();
surface_reset_target();

// Pass 3: Pre-Shaders (LINEAR)
surface_set_target(surf_prepass0);
    shader_set(shd_pre_shaders);
    push_shader_params(shd_pre_shaders, surf_afterglow[pingpong_write]);
    texture_set_stage(s_preshader_stock, surface_get_texture(surf_stock_pass));
    texture_set_stage(s_preshader_lut1, tex_lut1);
    texture_set_stage(s_preshader_lut2, tex_lut2);
    texture_set_stage(s_preshader_lut3, tex_lut3);
    texture_set_stage(s_preshader_lut4, tex_lut4);
    
    draw_surface(surf_afterglow[pingpong_write], 0, 0);
    shader_reset();
surface_reset_target();

// Pass 4: Interlace (LINEAR)
surface_set_target(surf_interlace);
    shader_set(shd_interlace);
    push_shader_params(shd_interlace, surf_prepass0);
    draw_surface(surf_prepass0, 0, 0);
    shader_reset();
surface_reset_target();

// Pass 5: NTSC Pass 1 (NEAREST)
// Encoding phase. Must use Nearest Neighbor.
gpu_set_tex_filter(false);
surface_set_target(surf_ntsc_1);
    shader_set(shd_ntsc_pass1);
    push_shader_params(shd_ntsc_pass1, surf_interlace);
    // Scale: 4x Game Width
    draw_surface_stretched(surf_interlace, 0, 0, game_width * 4.0, game_height);
    shader_reset();
surface_reset_target();

// Pass 6: NTSC Pass 2 (LINEAR)
// Decoding phase. Must use Linear Interpolation.
gpu_set_tex_filter(true);
surface_set_target(surf_ntsc_2);
    shader_set(shd_ntsc_pass2);
    push_shader_params(shd_ntsc_pass2, surf_ntsc_1);
    texture_set_stage(s_ntsc2_prepass0, surface_get_texture(surf_prepass0));
    // Scale: 2x Game Width
    draw_surface_stretched(surf_ntsc_1, 0, 0, _decoded_width, game_height);
    shader_reset();
surface_reset_target();

// Pass 7: NTSC Pass 3 (LINEAR)
surface_set_target(surf_ntsc_3);
    shader_set(shd_ntsc_pass3);
    push_shader_params(shd_ntsc_pass3, surf_ntsc_2);
    texture_set_stage(s_ntsc3_npass1, surface_get_texture(surf_ntsc_1));
    texture_set_stage(s_ntsc3_prepass0, surface_get_texture(surf_prepass0));
    // Maintain 2x Width
    draw_surface_stretched(surf_ntsc_2, 0, 0, _decoded_width, game_height);
    shader_reset();
surface_reset_target();

// Pass 8: Fast Sharpen (LINEAR)
surface_set_target(surf_ntsc_sharpen);
    shader_set(shd_fast_sharpen);
    push_shader_params(shd_fast_sharpen, surf_ntsc_3);
    texture_set_stage(s_sharpen_prepass0, surface_get_texture(surf_prepass0));
    // Maintain 2x Width
    draw_surface_stretched(surf_ntsc_3, 0, 0, _decoded_width, game_height);
    shader_reset();
surface_reset_target();

// Pass 9: Stock (Copy for Feedback) (LINEAR)
surface_set_target(surf_prepass);
    // Maintain 2x Width
    draw_surface_stretched(surf_ntsc_sharpen, 0, 0, _decoded_width, game_height);
surface_reset_target();

// Pass 10: Avg Lum (LINEAR)
surface_set_target(surf_avglum[pingpong_write]);
    shader_set(shd_avg_lum);
    push_shader_params(shd_avg_lum, surf_prepass);
    texture_set_stage(s_avglum_feedback, surface_get_texture(surf_avglum[pingpong_read]));
    
    draw_surface_stretched(surf_prepass, 0, 0, 1, 1);
    shader_reset();
surface_reset_target();

// Pass 11: Linearize (LINEAR)
surface_set_target(surf_linearize);
    shader_set(shd_linearize);
    push_shader_params(shd_linearize, surf_prepass);
    texture_set_stage(s_linearize_interlace, surface_get_texture(surf_interlace));
    // Maintain 2x Width
    draw_surface_stretched(surf_prepass, 0, 0, _decoded_width, game_height);
    shader_reset();
surface_reset_target();

// Pass 12: CRT Pass 1 (LINEAR)
// Scales UP to Viewport size
surface_set_target(surf_pass1);
    shader_set(shd_crt_pass1);
    push_shader_params(shd_crt_pass1, surf_linearize);
    draw_surface_stretched(surf_linearize, 0, 0, output_width, output_height);
    shader_reset();
surface_reset_target();

// Pass 13: Gaussian H (LINEAR)
// Scale: Bloom Width (800) x Game Height
surface_set_target(surf_gauss_h);
    shader_set(shd_gauss_h);
    push_shader_params(shd_gauss_h, surf_linearize);
    draw_surface_stretched(surf_linearize, 0, 0, bloom_width, game_height);
    shader_reset();
surface_reset_target();

// Pass 14: Gaussian V (LINEAR)
// Scale: Bloom Width x Bloom Height
surface_set_target(surf_glow);
    shader_set(shd_gauss_v);
    push_shader_params(shd_gauss_v, surf_gauss_h);
    draw_surface_stretched(surf_gauss_h, 0, 0, bloom_width, bloom_height);
    shader_reset();
surface_reset_target();

// Pass 15: Bloom H (LINEAR)
surface_set_target(surf_bloom_h);
    shader_set(shd_bloom_h);
    push_shader_params(shd_bloom_h, surf_linearize);
    draw_surface_stretched(surf_linearize, 0, 0, bloom_width, game_height);
    shader_reset();
surface_reset_target();

// Pass 16: Bloom V (LINEAR)
surface_set_target(surf_bloom);
    shader_set(shd_bloom_v);
    push_shader_params(shd_bloom_v, surf_bloom_h);
    draw_surface_stretched(surf_bloom_h, 0, 0, bloom_width, bloom_height);
    shader_reset();
surface_reset_target();

// Pass 17: CRT Pass 2 (LINEAR)
surface_set_target(surf_pass2);
    shader_set(shd_crt_pass2);
    push_shader_params(shd_crt_pass2, surf_pass1);
    texture_set_stage(s_crt2_linearize, surface_get_texture(surf_linearize));
    texture_set_stage(s_crt2_avglum, surface_get_texture(surf_avglum[pingpong_write]));
    texture_set_stage(s_crt2_bloom, surface_get_texture(surf_bloom));
    texture_set_stage(s_crt2_prepass, surface_get_texture(surf_prepass));
    
    draw_surface(surf_pass1, 0, 0);
    shader_reset();
surface_reset_target();


// --- 5. Final Output (LINEAR) ---
shader_set(shd_deconvergence);
    push_shader_params(shd_deconvergence, surf_pass2);
    texture_set_stage(s_decon_source, surface_get_texture(surf_pass2));
    texture_set_stage(s_decon_linearize, surface_get_texture(surf_linearize));
    texture_set_stage(s_decon_avglum, surface_get_texture(surf_avglum[pingpong_write]));
    texture_set_stage(s_decon_glow, surface_get_texture(surf_glow));
    texture_set_stage(s_decon_bloom, surface_get_texture(surf_bloom));
    texture_set_stage(s_decon_prepass0, surface_get_texture(surf_prepass0));
    texture_set_stage(s_decon_stock, surface_get_texture(surf_stock_pass));

    gpu_set_blendenable(false);
    draw_surface_stretched(surf_pass2, 0, 0, output_width, output_height);
    gpu_set_blendenable(true);
shader_reset();


// --- 6. Maintenance ---
frame_count++;
history_idx = (history_idx + 1) % history_size;

var _temp = pingpong_read;
pingpong_read = pingpong_write;
pingpong_write = _temp;